Atomic op: Action is unbreakable, happens in a single step.
SMP: Symmetric Multi Processing, every core can do everything, down side is that cashes are difficult to manage
NUMA: Non Uniform Memory Access, every core has own data, access to other cores' data requires a call
Phase change memory, memristor, can keep ram across shutoff. Merge ram and data storage. Down side is that you need to actively remove stored data if you want to reboot.
Battery-backed DRAM+flash
Non local memory: (Storage area network) High speed network connection to you HDD in a different box, (Memory area network) maybe for RAM too? Downside data breaches

//./configure comes from the gnu build system, includes autotools, autoconf, automake 
//includes 'Configuration Value' Called Triplet(x68_64-suse-Linux-distro) 
//generated by config.guess

//if cant find what system you are using
//updata config.guess, and config.sub

//run configure with '--prefix=/home/myUsername/test'

==to install==

./configure 
make
make install //DANGER //use 'make destdir=bla/bla/bla install'

Sudo setenforce 0 //Dissable security to test software

==Limitations to portablility==

Specific Compiler
Language versions + Extension
---------------------------------
32 vs 64 bit
Memory model/Programming model
LP64: long and pointers are 64bit
ILP32: Faster but limmited to 4gb
---------------------------------
big vs little endian
SMP vs NUMA vs
---------------------------------
Function / Class / Library Diff
Hardware specific libraries
System Calls
OpenGL bv. Directx
---------------------------------
Libraries or Intrinsics or Assemlar to access
HW capability {Accelerators/SIMD}
---------------------------------
Assembler{
			Atomics
			HW accel
			Mem Barrier
}
---------------------------------
Worse:
OS/Hardware specific libraries
Squezzing out Max performance

Better:
Abstraction Library
Standard SysCalls, libraries, tools, languages
Use specific datatype sizes
